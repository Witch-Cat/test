### Solved by barrebas

Obfuscation is a 150 point challenge. 

Tough one. There are some anti-disassembler tricks in here. Upon running the program, it asks for a password. Let's first try to get a breakpoint somewhere:

```
gdb-peda$ b main
Function "main" not defined.
gdb-peda$ b __libc_start_main
Breakpoint 1 at 0x8048400
gdb-peda$ r
...
Breakpoint 1, 0xf7e2c970 in __libc_start_main ()
   from /lib/i386-linux-gnu/i686/cmov/libc.so.6
gdb-peda$ x/2x $esp
0xffffd58c:	0x080484ed	0x08048420
```

Our entry-point is `0x08048420`. Set a breakpoint and continue tracing. We encounter an anti-disassembly trick:

```
=> 0x804843a:	jmp    0x804843b
 | 0x804843c:	ror    BYTE PTR [eax-0x39],0x44
 | 0x8048440:	and    al,0x4
 | 0x8048442:	push   esp
 | 0x8048443:	lea    eax,[eax+ecx*1]
 |->   0x804843b:	inc    eax
       0x804843d:	dec    eax
       0x804843e:	mov    DWORD PTR [esp+0x4],0x8048d54
       0x8048446:	mov    DWORD PTR [esp],0x1
```

It jumps one byte ahead, in the middle of the instruction, causing the disassembly of the next bytes to be incorrect. Luckily, this won't stop `gdb-peda`. Soon after, the program asks for a password:

```
=> 0x804846a:	call   0x80483c0 <getline@plt>
   0x804846f:	test   eax,eax

...

0x0804846a in ?? ()
gdb-peda$ b *0x804846f 
Breakpoint 2 at 0x804846f
```

I entered `012345678` and pressed enter. The program transfers control to the function at `0x8048580` which supposedly checks our password. Set a breakpoint and continue. The programs then takes a single byte from the password and does some checks:

```
   0x80485b6:	movzx  ebp,BYTE PTR [ebx+edx*1] # grab char
   0x80485ba:	mov    eax,ebp
   0x80485bc:	movsx  ecx,al
   0x80485bf:	add    ecx,0x40
   0x80485c2:	mov    edi,ecx
   0x80485c4:	sar    edi,0x1f                 # no idea what this 
   0x80485c7:	shr    edi,0x19                 # is supposed to do.
   0x80485ca:	add    ecx,edi
   0x80485cc:	and    ecx,0x7f                 # check for ASCII?
   0x80485cf:	sub    ecx,edi
   0x80485d1:	mov    BYTE PTR [esp+ecx*1+0xc],0x1
   0x80485d6:	lea    ecx,[ebp-0xa]            # subtract 0xa from char
   0x80485d9:	cmp    cl,0x70                  # check for below 'z'
   0x80485dc:	jbe    0x8048600
```

And then jumps to `0x8048600`. This piece is interesting, because it uses a jump-table (like in a switch statement). Depending on the value of (char - 0xa), it jumps to a code region:

```
=> 0x8048600:	movzx  ecx,cl
   0x8048603:	jmp    DWORD PTR [ecx*4+0x8048b90]

gdb-peda$ x/400x 0x8048b90
0x8048b90:	0x08048610	0x080485de	0x080485de	0x080485de
0x8048ba0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048bb0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048bc0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048bd0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048be0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048bf0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048c00:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048c10:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048c20:	0x080485de	0x080485de	0x08048628	0x08048640
0x8048c30:	0x08048658	0x08048678	0x08048698	0x080486c0
0x8048c40:	0x080486e0	0x08048708	0x08048730	0x08048758
0x8048c50:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048c60:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048c70:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048c80:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048c90:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048ca0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048cb0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048cc0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048cd0:	0x080485de	0x080485de	0x080485de	0x080485de
0x8048ce0:	0x080485de	0x080485de	0x080485de	0x08048780
0x8048cf0:	0x080487a0	0x080487c0	0x080487e0	0x08048800
0x8048d00:	0x08048820	0x08048840	0x08048858	0x08048878
0x8048d10:	0x08048898	0x080488b8	0x080488d0	0x080488f0
0x8048d20:	0x08048910	0x08048928	0x08048950	0x08048970
0x8048d30:	0x08048990	0x080489b0	0x080489d0	0x080489e8
0x8048d40:	0x08048a08	0x08048a28	0x08048a48	0x08048a68
0x8048d50:	0x08048a88	0x73736150	0x64726f77	0x4300203a
```

There are a lot of occurences of `0x080485de`:

```
   0x80485de:	xor    eax,eax
   0x80485e0:	mov    edx,DWORD PTR [esp+0x8c]
   0x80485e7:	xor    edx,DWORD PTR gs:0x14
   0x80485ee:	jne    0x8048ab0
   0x80485f4:	add    esp,0x9c
   0x80485fa:	pop    ebx
   0x80485fb:	pop    esi
   0x80485fc:	pop    edi
   0x80485fd:	pop    ebp
   0x80485fe:	ret    
```

Which basically means "get out of here, your password isn't correct". I decided to continue and see what the code did:

```
=> 0x8048603:	jmp    DWORD PTR [ecx*4+0x8048b90]
 | 0x804860a:	lea    esi,[esi+0x0]
 | 0x8048610:	cmp    edx,0xd
 | 0x8048613:	sete   dl
 | 0x8048616:	xor    eax,eax
 |->   0x8048628:	test   edx,edx
       0x804862a:	jne    0x80485de
       0x804862c:	cmp    BYTE PTR [esp+0x7c],0x0
       0x8048631:	je     0x80485de
       0x8048633:	mov    edx,0x1
       0x8048638:	jmp    0x80485ab
```

It checks if `edx` is zero. If it is, it checks if some memory location is zero (it was) and then sets edx to 1. It then goes back to the code where a byte is taken from the password. Only this time, it would be the second byte! This means that I accidentally guessed the first char of the password right. The next one was not correct, as I supplied `1` which then jumps to:

```
   0x8048640:	cmp    edx,0xe
   0x8048643:	jne    0x80485de
   0x8048645:	cmp    BYTE PTR [esp+0x7d],0x0
   0x804864a:	je     0x80485de
   0x804864c:	mov    edx,0xf
   0x8048651:	jmp    0x80485ab
   0x8048656:	xchg   ax,ax
```

Because `edx` was not set to `0xe`, the check fails and the password is incorrect. From here on, I dumped the jumptable and gave each memory location a label using a python script:

```
0x08048610:
...snip...
0x080485de:!
0x080485de:"
0x080485de:#
0x080485de:$
0x080485de:%
0x080485de:&
0x080485de:'
0x080485de:(
0x080485de:)
0x080485de:*
0x080485de:+
0x080485de:,
0x080485de:-
0x080485de:.
0x080485de:/
0x08048628:0
0x08048640:1
0x08048658:2
0x08048678:3
0x08048698:4
0x080486c0:5
0x080486e0:6
0x08048708:7
0x08048730:8
0x08048758:9
0x080485de::
0x080485de:;
0x080485de:<
0x080485de:=
0x080485de:>
0x080485de:?
0x080485de:@
0x080485de:A
0x080485de:B
0x080485de:C
0x080485de:D
0x080485de:E
0x080485de:F
0x080485de:G
0x080485de:H
0x080485de:I
0x080485de:J
0x080485de:K
0x080485de:L
0x080485de:M
0x080485de:N
0x080485de:O
0x080485de:P
0x080485de:Q
0x080485de:R
0x080485de:S
0x080485de:T
0x080485de:U
0x080485de:V
0x080485de:W
0x080485de:X
0x080485de:Y
0x080485de:Z
0x080485de:[
0x080485de:\
0x080485de:]
0x080485de:^
0x080485de:_
0x080485de:`
0x08048780:a
0x080487a0:b
0x080487c0:c
0x080487e0:d
0x08048800:e
0x08048820:f
0x08048840:g
0x08048858:h
0x08048878:i
0x08048898:j
0x080488b8:k
0x080488d0:l
0x080488f0:m
0x08048910:n
0x08048928:o
0x08048950:p
0x08048970:q
0x08048990:r
0x080489b0:s
0x080489d0:t
0x080489e8:u
0x08048a08:v
0x08048a28:w
0x08048a48:x
0x08048a68:y
0x08048a88:z
```

Then I dumped all the instructions starting at `0x8048610` and labelled them:

```
   // 0x0a
   0x8048610:	cmp    edx,0xd	
   0x8048613:	sete   dl
   0x8048616:	xor    eax,eax
   0x8048618:	cmp    BYTE PTR [esp+0x56],0x0
   0x804861d:	setne  al
   0x8048620:	and    eax,edx
   0x8048622:	jmp    0x80485e0
   0x8048624:	lea    esi,[esi+eiz*1+0x0]
   // 0x08048628:0
   0x8048628:	test   edx,edx
   0x804862a:	jne    0x80485de
   0x804862c:	cmp    BYTE PTR [esp+0x7c],0x0
   0x8048631:	je     0x80485de
   0x8048633:	mov    edx,0x1
   0x8048638:	jmp    0x80485ab
   0x804863d:	lea    esi,[esi+0x0]
   // 0x08048640:1
   0x8048640:	cmp    edx,0xe
   0x8048643:	jne    0x80485de
   0x8048645:	cmp    BYTE PTR [esp+0x7d],0x0
   0x804864a:	je     0x80485de
   0x804864c:	mov    edx,0xf
   0x8048651:	jmp    0x80485ab
   0x8048656:	xchg   ax,ax
   // 0x08048658:2
   0x8048658:	cmp    edx,0x14
   0x804865b:	jne    0x80485de
   0x804865d:	cmp    BYTE PTR [esp+0x7e],0x0
   0x8048662:	je     0x80485de
   0x8048668:	mov    edx,0x15
   0x804866d:	jmp    0x80485ab
   0x8048672:	lea    esi,[esi+0x0]
   // 0x08048678:3
   0x8048678:	cmp    edx,0x59
   0x804867b:	jne    0x80485de
   0x8048681:	cmp    BYTE PTR [esp+0x7f],0x0
   0x8048686:	je     0x80485de
   0x804868c:	mov    edx,0x5a
   0x8048691:	jmp    0x80485ab
   0x8048696:	xchg   ax,ax
   // 0x08048698:4
   0x8048698:	cmp    edx,0xf
   0x804869b:	jne    0x80485de
   0x80486a1:	cmp    BYTE PTR [esp+0x80],0x0
   0x80486a9:	je     0x80485de
   0x80486af:	mov    edx,0x10
   0x80486b4:	jmp    0x80485ab
   0x80486b9:	lea    esi,[esi+eiz*1+0x0]
   // 0x080486c0:5
   0x80486c0:	cmp    edx,0xe
   0x80486c3:	jne    0x80485de
   0x80486c9:	cmp    BYTE PTR [esp+0x81],0x0
   0x80486d1:	jne    0x804864c
   0x80486d7:	jmp    0x80485de
   0x80486dc:	lea    esi,[esi+eiz*1+0x0]
   // 0x080486e0:6
   0x80486e0:	cmp    edx,0xc
   0x80486e3:	jne    0x80485de
   0x80486e9:	cmp    BYTE PTR [esp+0x82],0x0
   0x80486f1:	je     0x80485de
   0x80486f7:	mov    edx,0xd
   0x80486fc:	jmp    0x80485ab
   0x8048701:	lea    esi,[esi+eiz*1+0x0]
   // 0x08048708:7
   0x8048708:	cmp    edx,0x5
   0x804870b:	jne    0x80485de
   0x8048711:	cmp    BYTE PTR [esp+0x83],0x0
   0x8048719:	je     0x80485de
   0x804871f:	mov    edx,0x6
   0x8048724:	jmp    0x80485ab
   0x8048729:	lea    esi,[esi+eiz*1+0x0]
   // ?? 0x08048730:8
   0x8048730:	xor    eax,eax
   0x8048732:	cmp    BYTE PTR [esp+0x85],0x0
   0x804873a:	je     0x80485e0
   0x8048740:	cmp    edx,0x2
   0x8048743:	sete   al
   0x8048746:	cmp    edx,0x21
   0x8048749:	sete   dl
   0x804874c:	or     eax,edx
   0x804874e:	movzx  eax,al
   0x8048751:	jmp    0x80485e0
   0x8048756:	xchg   ax,ax
   // 0x08048758:9
   0x8048758:	cmp    edx,0x1
   0x804875b:	jne    0x80485de
   0x8048761:	cmp    BYTE PTR [esp+0x85],0x0
   0x8048769:	je     0x80485de
   0x804876f:	mov    edx,0x2
   0x8048774:	jmp    0x80485ab
   0x8048779:	lea    esi,[esi+eiz*1+0x0]
   // 0x08048780:a
   0x8048780:	cmp    edx,0x23
   0x8048783:	jne    0x80485de
   0x8048789:	cmp    BYTE PTR [esp+0x2d],0x0
   0x804878e:	je     0x80485de
   0x8048794:	mov    edx,0x24
   0x8048799:	jmp    0x80485ab
   0x804879e:	xchg   ax,ax
   // 0x080487a0:b
   0x80487a0:	cmp    edx,0xb
   0x80487a3:	jne    0x80485de
   0x80487a9:	cmp    BYTE PTR [esp+0x2e],0x0
   0x80487ae:	je     0x80485de
   0x80487b4:	mov    edx,0xc
   0x80487b9:	jmp    0x80485ab
   0x80487be:	xchg   ax,ax
   0x080487c0:c
   0x80487c0:	cmp    edx,0x20
   0x80487c3:	jne    0x80485de
   0x80487c9:	cmp    BYTE PTR [esp+0x2d],0x0
   0x80487ce:	je     0x80485de
   0x80487d4:	mov    edx,0x21
   0x80487d9:	jmp    0x80485ab
   0x80487de:	xchg   ax,ax
	// 0x080487e0:d
   0x80487e0:	cmp    edx,0x3
   0x80487e3:	jne    0x80485de
   0x80487e9:	cmp    BYTE PTR [esp+0x30],0x0
   0x80487ee:	je     0x80485de
   0x80487f4:	mov    edx,0x4
   0x80487f9:	jmp    0x80485ab
   0x80487fe:	xchg   ax,ax
   // 0x08048800:e
   0x8048800:	cmp    edx,0x7
   0x8048803:	jne    0x80485de
   0x8048809:	cmp    BYTE PTR [esp+0x31],0x0
   0x804880e:	je     0x80485de
   0x8048814:	mov    edx,0x8
   0x8048819:	jmp    0x80485ab
   0x804881e:	xchg   ax,ax
   // 0x08048820:f
   0x8048820:	cmp    BYTE PTR [esp+0x32],0x0
   0x8048825:	je     0x80485de
   0x804882b:	cmp    edx,0x8
   0x804882e:	jne    0x8048a9f
   0x8048834:	add    edx,0x1
   0x8048837:	jmp    0x80485ab
   0x804883c:	lea    esi,[esi+eiz*1+0x0]
   // 0x08048840:g
   0x8048840:	cmp    edx,0xc
   0x8048843:	sete   dl
   0x8048846:	xor    eax,eax
   0x8048848:	cmp    BYTE PTR [esp+0x40],0x0
   0x804884d:	setne  al
   0x8048850:	and    eax,edx
   0x8048852:	jmp    0x80485e0
   0x8048857:	nop
   // 0x08048858:h
   0x8048858:	cmp    edx,0xd
   0x804885b:	jne    0x80485de
   0x8048861:	cmp    BYTE PTR [esp+0x33],0x0
   0x8048866:	je     0x80485de
   0x804886c:	mov    edx,0xe
   0x8048871:	jmp    0x80485ab
   0x8048876:	xchg   ax,ax
   // 0x08048878:i
   0x8048878:	cmp    edx,0x9
   0x804887b:	jne    0x80485de
   0x8048881:	cmp    BYTE PTR [esp+0x35],0x0
   0x8048886:	je     0x80485de
   0x804888c:	mov    edx,0xa
   0x8048891:	jmp    0x80485ab
   0x8048896:	xchg   ax,ax
   // 0x08048898:j
   0x8048898:	cmp    edx,0xa
   0x804889b:	jne    0x80485de
   0x80488a1:	cmp    BYTE PTR [esp+0x36],0x0
   0x80488a6:	je     0x80485de
   0x80488ac:	mov    edx,0xb
   0x80488b1:	jmp    0x80485ab
   0x80488b6:	xchg   ax,ax
   // 0x080488b8:k
   0x80488b8:	cmp    edx,0xc
   0x80488bb:	sete   dl
   0x80488be:	xor    eax,eax
   0x80488c0:	cmp    BYTE PTR [esp+0x37],0x0
   0x80488c5:	setne  al
   0x80488c8:	and    eax,edx
   0x80488ca:	jmp    0x80485e0	<- terminate, compares eax to 1. If it is, the string is correct! Flag = 09vdf7wefijbkh
   0x80488cf:	nop
   // 0x080488d0:l
   0x80488d0:	cmp    edx,0x13
   0x80488d3:	jne    0x80485de
   0x80488d9:	cmp    BYTE PTR [esp+0x38],0x0
   0x80488de:	je     0x80485de
   0x80488e4:	mov    edx,0x14
   0x80488e9:	jmp    0x80485ab
   0x80488ee:	xchg   ax,ax
   // 0x080488f0:m
   0x80488f0:	cmp    edx,0x11
   0x80488f3:	jne    0x80485de
   0x80488f9:	cmp    BYTE PTR [esp+0x39],0x0
   0x80488fe:	je     0x80485de
   0x8048904:	mov    edx,0x12
   0x8048909:	jmp    0x80485ab
   0x804890e:	xchg   ax,ax
   // 0x08048910:n
   0x8048910:	cmp    edx,0x12
   0x8048913:	sete   dl
   0x8048916:	xor    eax,eax
   0x8048918:	cmp    BYTE PTR [esp+0x39],0x0
   0x804891d:	setne  al
   0x8048920:	and    eax,edx
   0x8048922:	jmp    0x80485e0
   0x8048927:	nop
   // 0x08048928:o
   0x8048928:	cmp    BYTE PTR [esp+0x3a],0x0
   0x804892d:	je     0x80485de
   0x8048933:	cmp    edx,0x6
   0x8048936:	je     0x8048834
   0x804893c:	cmp    edx,0x1c
   0x804893f:	je     0x8048834
   0x8048945:	jmp    0x80485de
   0x804894a:	lea    esi,[esi+0x0]
   // 0x08048950:p
   0x8048950:	cmp    edx,0x1e
   0x8048953:	jne    0x80485de
   0x8048959:	cmp    BYTE PTR [esp+0x3c],0x0
   0x804895e:	xchg   ax,ax
   0x8048960:	je     0x80485de
   0x8048966:	mov    edx,0x1f
   0x804896b:	jmp    0x80485ab
   // 0x08048970:q
   0x8048970:	cmp    edx,0x1d
   0x8048973:	jne    0x80485de
   0x8048979:	cmp    BYTE PTR [esp+0x3d],0x0
   0x804897e:	je     0x80485de
   0x8048984:	mov    edx,0x1e
   0x8048989:	jmp    0x80485ab
   0x804898e:	xchg   ax,ax
   // 0x08048990:r
   0x8048990:	cmp    edx,0x14
   0x8048993:	jne    0x80485de
   0x8048999:	cmp    BYTE PTR [esp+0x3e],0x0
   0x804899e:	jne    0x8048668
   0x80489a4:	jmp    0x80485de
   0x80489a9:	lea    esi,[esi+eiz*1+0x0]
   // 0x080489b0:s
   0x80489b0:	cmp    edx,0x19
   0x80489b3:	jne    0x80485de
   0x80489b9:	cmp    BYTE PTR [esp+0x3f],0x0
   0x80489be:	xchg   ax,ax
   0x80489c0:	je     0x80485de
   0x80489c6:	mov    edx,0x1a
   0x80489cb:	jmp    0x80485ab
   // 0x080489d0:t
   0x80489d0:	cmp    edx,0x18
   0x80489d3:	sete   dl
   0x80489d6:	xor    eax,eax
   0x80489d8:	cmp    BYTE PTR [esp+0x3e],0x0
   0x80489dd:	setne  al
   0x80489e0:	and    eax,edx
   0x80489e2:	jmp    0x80485e0
   0x80489e7:	nop
   // 0x080489e8:u
   0x80489e8:	cmp    edx,0x1a
   0x80489eb:	jne    0x80485de
   0x80489f1:	cmp    BYTE PTR [esp+0x41],0x0
   0x80489f6:	je     0x80485de
   0x80489fc:	mov    edx,0x1b
   0x8048a01:	jmp    0x80485ab
   0x8048a06:	xchg   ax,ax
   // 0x08048a08:v
   0x8048a08:	cmp    edx,0x2
   0x8048a0b:	jne    0x80485de
   0x8048a11:	cmp    BYTE PTR [esp+0x42],0x0
   0x8048a16:	je     0x80485de
   0x8048a1c:	mov    edx,0x3
   0x8048a21:	jmp    0x80485ab
   0x8048a26:	xchg   ax,ax
   // 0x08048a28:w
   0x8048a28:	cmp    edx,0x6
   0x8048a2b:	jne    0x80485de
   0x8048a31:	cmp    BYTE PTR [esp+0x43],0x0
   0x8048a36:	je     0x80485de
   0x8048a3c:	mov    edx,0x7
   0x8048a41:	jmp    0x80485ab
   0x8048a46:	xchg   ax,ax
   // 0x08048a48:x
   0x8048a48:	cmp    edx,0x16
   0x8048a4b:	jne    0x80485de
   0x8048a51:	cmp    BYTE PTR [esp+0x44],0x0
   0x8048a56:	je     0x80485de
   0x8048a5c:	mov    edx,0x17
   0x8048a61:	jmp    0x80485ab
   0x8048a66:	xchg   ax,ax
   // 0x08048a68:y
   0x8048a68:	cmp    edx,0x17
   0x8048a6b:	jne    0x80485de
   0x8048a71:	cmp    BYTE PTR [esp+0x45],0x0
   0x8048a76:	je     0x80485de
   0x8048a7c:	mov    edx,0x18
   0x8048a81:	jmp    0x80485ab
   0x8048a86:	xchg   ax,ax
   // 0x08048a88:z
   0x8048a88:	cmp    edx,0x15
   0x8048a8b:	sete   dl
   0x8048a8e:	xor    eax,eax
   0x8048a90:	cmp    BYTE PTR [esp+0x2d],0x0
   0x8048a95:	setne  al
   0x8048a98:	and    eax,edx
   0x8048a9a:	jmp    0x80485e0
   0x8048a9f:	cmp    edx,0x4
   0x8048aa2:	je     0x8048834
   0x8048aa8:	jmp    0x80485de
   0x8048aad:	lea    esi,[esi+0x0]
   0x8048ab0:	call   0x80483e0 <__stack_chk_fail@plt>
```

From here, it was a matter of following the `mov edx, <n>` and `cmp edx, <n>` instructions. For instance, the first correct char of the password is '0'. `edx` is then set to 1. Next, I located the block:

```
   // 0x08048758:9
   0x8048758:	cmp    edx,0x1
   0x804875b:	jne    0x80485de
   0x8048761:	cmp    BYTE PTR [esp+0x85],0x0
   0x8048769:	je     0x80485de
   0x804876f:	mov    edx,0x2
   0x8048774:	jmp    0x80485ab
```

So the next valid char must be `9`. I continued this process until I got up to 0x10. There was no `cmp edx, 0x10`. I verified the chars I had so far. It seems there is some trolling going on. There are two blocks that check for `cmp edx, 0x6`:

```
   // 0x08048a28:w
   0x8048a28:	cmp    edx,0x6
   0x8048a2b:	jne    0x80485de
   0x8048a31:	cmp    BYTE PTR [esp+0x43],0x0
   0x8048a36:	je     0x80485de
   0x8048a3c:	mov    edx,0x7
   0x8048a41:	jmp    0x80485ab
   0x8048a46:	xchg   ax,ax
   
   ...and...
   
   // 0x08048928:o
   0x8048928:	cmp    BYTE PTR [esp+0x3a],0x0
   0x804892d:	je     0x80485de
   0x8048933:	cmp    edx,0x6
   0x8048936:	je     0x8048834
   0x804893c:	cmp    edx,0x1c
   0x804893f:	je     0x8048834
   0x8048945:	jmp    0x80485de
   0x804894a:	lea    esi,[esi+0x0]
```

At first, I had selected 'o', but it turns out it should have been 'w'. The string comparison stops at 'k':

```
   // 0x080488b8:k
   0x80488b8:	cmp    edx,0xc
   0x80488bb:	sete   dl
   0x80488be:	xor    eax,eax
   0x80488c0:	cmp    BYTE PTR [esp+0x37],0x0
   0x80488c5:	setne  al
   0x80488c8:	and    eax,edx
   0x80488ca:	jmp    0x80485e0	<- terminate, compares eax to 1. 
                                       If it is, the string is correct!
   0x80488cf:	nop
```

Through a bit of trial-and-error I arrived at the password:

```
bas@tritonal:~/tmp/picoctf/obfus$ ./obfuscate 
Password: 09vdf7wefijbkh
Correct!
```

So the flag is `09vdf7wefijbkh`.
